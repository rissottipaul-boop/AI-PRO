# ADR-0002: Система саамообучения и оптимизации производительности

## Статус

**Accepted** и реализовано

## Контекст

Автономная система разработки должна не только выполнять задачи, но и учиться на результатах своей работы, выявляя паттерны и оптимизируя процессы. Без механизма обратной связи система остаётся статичной и не может адаптироваться к изменяющимся условиям.

## Проблема

Нужен способ:
1. Собирать метрики о процессе разработки (время тестов, покрытие, производительность)
2. Анализировать тренды и выявлять проблемы
3. Генерировать рекомендации по оптимизации
4. Применять стратегии повышения производительности

## Решение

Реализована трёхкомпонентная система:

### 1. MetricsTracker

**Назначение**: Сбор и хранение метрик

**Возможности**:
- Запись произвольных метрик с метаданными
- Опциональное персистентное хранилище (JSON)
- Анализ трендов (возрастание, убывание, стабильность)
- Статистические сводки (среднее, мин, макс)

**Пример**:
```python
tracker = MetricsTracker(storage_path="metrics.json")
tracker.record_metric("test_duration", 12.5, {"suite": "unit"})
trends = tracker.analyze_trends("test_duration")
```

### 2. FeedbackLoop

**Назначение**: Анализ итераций и генерация инсайтов

**Возможности**:
- Оценка каждой итерации разработки
- Генерация рекомендаций с уровнем уверенности
- Контекстно-зависимые советы (тип задачи влияет на рекомендации)
- Приоритизация инсайтов

**Категории инсайтов**:
- performance (скорость, эффективность)
- quality (качество кода, maintainability)
- testing (покрытие, надёжность)
- security (безопасность)
- maintenance (технический долг)

**Пример**:
```python
loop = FeedbackLoop(tracker)
insights = loop.evaluate_iteration({
    "test_duration": 15.2,
    "coverage": 94.5
})
suggestions = loop.suggest_optimizations({"task_type": "testing"})
```

### 3. PerformanceOptimizer

**Назначение**: Применение стратегий оптимизации

**Возможности**:
- LRU кэширование дорогих операций
- Профилирование выполнения
- Пакетная обработка
- Управление ресурсами

**Пример**:
```python
optimizer = PerformanceOptimizer()

@optimizer.cache(maxsize=128)
def expensive_function(param):
    return result

@optimizer.profile
def monitored_function():
    pass
```

## Стратегия обучения

### Pattern Recognition
После накопления достаточного количества данных (обычно 5+ замеров) система:
- Выявляет тренды (возрастание/убывание)
- Вычисляет статистики
- Сравнивает с пороговыми значениями

### Adaptive Thresholds
Пороги качества адаптируются на основе исторической производительности:
- Если покрытие стабильно >95% → можно поднять требования
- Если тесты ускорились → можно добавить больше тестов

### Context-Aware Suggestions
Рекомендации зависят от типа задачи:
- Refactoring → фокус на структуре, дублировании, maintainability
- Testing → фокус на покрытии, скорости, flakiness
- Performance → фокус на оптимизации, профилировании

## Последствия

### Положительные
- ✅ Система становится самоулучшающейся
- ✅ Автоматическое выявление узких мест
- ✅ Проактивные рекомендации по оптимизации
- ✅ Исторические данные для принятия решений
- ✅ Прозрачность процесса (метрики видны)

### Риски
- ⚠️ Накладные расходы на мониторинг (минимальны)
- ⚠️ Память для кэша (настраиваемо)
- ⚠️ Ложноположительные инсайты при малом объеме данных (уровень уверенности помогает)

### Поддержка
- Полное покрытие тестами (100%)
- Строгая типизация (mypy strict)
- Документация в коде

## Альтернативы

### 1. Использовать внешние системы мониторинга
(Prometheus, Grafana)
- **Плюсы**: Зрелые решения, богатый функционал
- **Минусы**: Зависимости, сложность для минималистичного проекта
- **Вердикт**: Оставляем как будущее расширение

### 2. ML-модели для предсказаний
- **Плюсы**: Более точные прогнозы
- **Минусы**: Overhead, требует большого объема данных
- **Вердикт**: Преждевременно, начинаем с правил

### 3. Только in-memory метрики
(без персистентности)
- **Плюсы**: Проще, быстрее
- **Минусы**: Теряем историю между запусками
- **Вердикт**: Опциональная персистентность — best of both worlds

## Метрики успеха

1. **Покрытие тестами** ≥ 85% ✅ (достигнуто: 100%)
2. **Нулевые ошибки линтинга** ✅
3. **Строгая типизация** ✅
4. **Используемые метрики**: test_duration, coverage_percent, и др.
5. **Генерация инсайтов** при достаточном объеме данных

## Реализация

- **Файлы**:
  - `src/autonomous_dev/learning.py` — основная реализация
  - `tests/test_learning.py` — тесты
  - `SELF_LEARNING_GUIDE.md` — руководство пользователя

- **Интеграция**:
  - Используется в CI для сбора метрик
  - Опционально в локальной разработке
  - Артефакты сохраняются между запусками

## Дата

2025-10-04

## Авторы

Autonomous Development System

## Ссылки

- Implementation: `src/autonomous_dev/learning.py`
- Tests: `tests/test_learning.py`
- User Guide: `SELF_LEARNING_GUIDE.md`
